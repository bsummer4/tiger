(* tiger.grm *)

open AST;
open Symbol;

%%

%name Tiger
%eop Eof
%pos int
%noshift Eof
%start prog
%verbose 

%term Eof | String of string | Integer of int | Id of string
    | Comma | Colon | Semi | Lparen | Rparen | Lbrak | Rbrak | Lbrace | Rbrace
    | Dot | Plus | Minus | Mult | Div | Eq | Neq | Lt | Leq | Gt | Geq | And
    | Or | Assign | Array | If | Then | Else | While | For | To | Do | Let
    | In | End | Of | Break | Nil | Fun | Var | Type

%nonterm prog of exp 
       | exp of exp 
       | const of exp
       | string of exp
       | number of exp
       | seq of exp
       | seq' of (exp * pos) list
       | call of exp
       | args of exp list
       | record of exp
       | fields of (sym * exp * pos) list

%%

prog : exp (exp)

exp : const  (const)
    | seq    (seq)
    | call   (call)
    | record (record)

const : String  (STR(String,Stringleft))
      | Integer (INT Integer)
      | Nil     (NIL)

seq  : Lparen Rparen (SEQ [])
     | Lparen seq' Rparen (SEQ seq')
seq' : seq' Semi exp ((exp,expleft) :: seq')
     | exp ([(exp,expleft)])

call : Id Lparen Rparen (CALL {func=mk Id, args=[], pos=Idleft})
     | Id Lparen args Rparen (CALL {func=mk Id, args=args, pos=Idleft})
args : args Comma exp (exp :: args)
     | exp ([exp])

record : Id Lbrace Rbrace (REC {typ = mk Id, fields=[], pos=Idleft})
       | Id Lbrace fields Rbrace (REC {typ = mk Id, fields=fields  ,pos=Idleft})
fields : fields Comma Id Eq exp ((mk Id, exp, Idleft) :: fields)
       | Id Eq exp ([(mk Id, exp, Idleft)])
