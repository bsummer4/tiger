# The Tiger Language
Material for teaching compilers is forced to choose between focusing on
language design or focusing on compiler implementation.  Asking students
to design their own language requires significant investment and takes
a lot of time away from the compiler implementation.  Furthermore,
students with poor initial designs will end up spending a significant
amount of time repeatedly redesigning the languages as they come against
the limitations of their initial designs.  One alternative is to provide
students with a pre-designed language.  This allows the students to focus
on compiler implementation, but doesn't completely remove the language
design aspect from the material.  Students can implement an initial
compiler for a simple, canned language, then later, design extensions
for it.  A Language must be carefully designed if it is intended to be
used in this way.

Tiger is a programming language that was designed for this purpose
by Andrew W. Appel.  It was released along with his book, Modern
Compiler Implementation, as the primary source language.  There are
actually three books, each with the same material but using different
implementation languages.  The book focuses on implementing a compiler
of some sophistication for languages with modern features.

The book is broken down into two sections.  The first is designed for
an undergraduate compilers course where students implement a simple
but complete compiler for Tiger.  The second is designed to focus
on adding advanced language features and optimizations.  Because of
this format, Tiger had to be carefully designed to meet both needs.
Tiger itself only directly fulfills the needs of the first section, but
it is designed to be easily evolved into a more sophisticated language.
Specifically, the design of Tiger makes it easy to add functional and
object-oriented features.

Tiger tries to be simple to implement by supporting only the bare minimum
set of features required to write realistic programs.  It contains only
a handful of object types, built-in functions, and control structures.
There is a primitive, static type system with manifest type declarations.
Like many languages, primitive objects are passed by value, and compound
objects, which are always stored on the heap, are passed by reference.

## The Type System
Tiger's type system is very straightforward to implement.  The overall
simplicity of the type system makes types easy to verify and makes
code generation simple.  Manifest type declarations avoid the need
for complicated type-inference algorithms, while static typing saves
a lot of trouble outputting switches in the code generation pass.
Static type systems also make it possible to generate efficient code
without complicated interprocedural optimizations.

## Data Structures and Pointers
Tiger's heap-allocated arrays and records are necessary for implementing
data structures such as lists and trees.  Automatic heap management
also gives compiler-writers an opportunity to learn about the various
garbage collection techniques.  While Tiger implementations clearly
must use pointers in their implementation of heap-allocated objects,
the language does not make pointers first-class.  This makes it possible
to use precise garbage collection algorithms.  Languages with explicit
pointer manipulation are forced to use conservative garbage collection
algorithms which are slower and much more difficult to implement.

## Major Extensions
Tiger's nested functions and heap-allocated records make it easy to
extend the language with first class functions, objects, and classes.
First class functions can be added simply by inserting syntax for
function type declarations and by adding back-end code to handle closures.
An object is simply a record containing a set of closures and variables,
while a class need be nothing more than a simple syntactic extension to
make constructing objects more convenient.  There are several easy ways
a to handle interface or subclass polymorphism.

# Class Project
For our project, we will attempt to build a Tiger compiler
that compiles to C and to x86.  We'd also like to implement some
extensions: higher-order functions, region-based memory manegement,
a foreign-function-interface, and optional dynamic typing.  We want to
support compiling to C and to x86.

Region-based memory management is an optimization;  It doesn't change
the language.  The foreign-function interface would parse C header
files, and make defined functions callable in the global namespace.
Higher-order functions means that you may pass and return functions.
Here is an example that uses higher-order-functions and dynamic-typing
For example, this evaluates to 3:

| let
|  type icons = int -> dyn
|  function icons (car: dyn, cdr: dyn) : icons =
|   let function hof (int choice) = if (choice) then car else cdr
|   in hof
|   end
|  function car (pair: icons) : dyn = icons(1)
|  function cdr (pair: icons) : dyn = icons(0)
| in int(car(cons(dyn(3),dyn(4))))
| end

:TODO: Simple examples with explainations

# Summary of Features
## Feature Summary
Tiger has integers, strings, records, and arrays.

Tiger has four types of control flow.  'if' comes in two forms; the else
may be ommited or not.  If there is an else clause, then the 'if' form
returns a value ant the two branches must have matching types.   If the
else is ommited, then the expression doesn't return a value.

| x := if 3-4 then 3 else 4;
| if x then print ("3-3!")

'while' loops work the way you'd expect, and 'for' loops over a range
of integers.

| while not("!"=getchar()) do print(".")
| for (i := 0 to N) do (printi(i); print("\n"))

semicolons work the same way as comma in c except chains of
expressions must be parenthisised:

	| x := (printi 4; 3)

Operators: +, -, *, /, =, <>, <, >, >=, <=, &, and |

	All of these work the same as in c except <> means !=, & means &&
	and | means ||.

- Standard Library
	- function print (s:string)
	- function printi (i:int)
	- function flush ()
	- function getchar () : string
		read a character

	- function ord (s:string) : int
		Returns the integer value of the first character in
		strings s.

	- function chr (i:int) : string
		Returns the character represented by character code i.

	- function size (s:string) : int
		The length of a string

	- function substring (s:string, f:int, n:int) : string
		f is the index of the first character to include.
		n is the number of characters to include.

	- function concat (s1:string, s2:string) : string
		Returns the concatenation of strings s1 and s2.

	- function not (i:int) : int
		if 0 = i then 1 else 0

	- function exit (i:int)
		Exits the program with error code i.

## Example Programs
These are copied from the book, Modern Compiler Implementation in ML.

### Hello World
| print "Hello World\n";

### The 8-Queens Problem
| let
|  var N := 8
|  type intArray = array of int
|  var row := intArray [ N ] of 0
|  var col := intArray [ N ] of 0
|  var diag1 := intArray [ N+N-1 ] of 0
|  var diag2 := intArray [ N+N-1 ] of 0
|
|  function printboard() =
|   (for i := 0 to N-1
|    do (for j := 0 to N-1
|        do print(if col[i]=j then " O"
|                 else " .");
|        print("\n"));
|    print("\n"))
|
|  function try(c:int) =
|   if c=N then printboard()
|   else for r := 0 to N-1
|        do if row[r]=0 & diag1[r+c]=0
|               & diag2[r+7-c]=0
|           then (row[r] := 1;
|                 diag1[r+c] := 1;
|                 diag2[r+7-c] := 1;
|                 col[c] := r;
|                 try(c+1);
|                 row[r] := 0;
|                 diag1[r+c] := 0;
|                 diag2[r+7-c] := 0)
| in try(0) end

### Merge
| let
|  type any = {any : int}
|  var buffer := getchar()
|  function readint (any:any) : int =
|   let var i := 0
|       function isdigit (s:string) : int =
|        ord(buffer)>=ord("0") & ord(buffer)<=ord("9")
|       function skipto () =
|        while buffer=" " | buffer="\n"
|        do buffer := getchar()
|   in skipto();
|      any.any := isdigit(buffer);
|      while isdigit(buffer)
|      do (i := i*10+ord(buffer)-ord("0"); buffer := getchar());
|      i
|   end
|
|  type list = {first: int, rest: list}
|  function readlist() : list =
|   let var any := any{any=0}
|       var i := readint(any)
|   in if any.any
|      then list{first=i,rest=readlist()}
|      else nil
|   end
|
|  function merge(a: list, b: list) : list =
|   if a=nil then b
|   else if b=nil then a
|   else if a.first < b.first
|        then list{first=a.first,rest=merge(a.rest,b)}
|        else list{first=b.first,rest=merge(a,b.rest)}
|
|  function printint(i: int) =
|   let function f(i:int) =
|        if i>0 then (f(i/10); print(chr(i-i/10*10+ord("0"))))
|   in if i<0 then (print("-"); f(-i))
|      else if i>0 then f(i)
|      else print("0")
|   end
|
|  function printlist(l: list) =
|   if l=nil then print("\n")
|   else (printint(l.first); print(" "); printlist(l.rest))
|
|  var list1 := readlist()
|  var list2 := (buffer:=getchar(); readlist())
| in printlist(merge(list1,list2))
| end
